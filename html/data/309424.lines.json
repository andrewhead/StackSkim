[
  {
    "id_": 24810414, 
    "lines": [
      {
        "text": "I'd use some Java 8 tricks.", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "public static String streamToString(final InputStream inputStream) throws Exception", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "{", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    try", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        final BufferedReader br // buffering optional", 
        "type_": "codecommentinline", 
        "references": []
      }, 
      {
        "text": "           = new BufferedReader(new InputStreamReader(inputStream)))", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        return br.lines().parallel().collect(Collectors.joining(\"\\n\"));", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "                       // parallel optional", 
        "type_": "codecommentinline", 
        "references": []
      }, 
      {
        "text": "    }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    catch (IOException e)", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        throw new RuntimeException(e);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        // whatever.", 
        "type_": "codecommentinline", 
        "references": []
      }, 
      {
        "text": "    }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "Essentially the same as some other answers except more succinct.", 
        "type_": "text", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 22960005, 
    "lines": [
      {
        "text": "Here is the complete method for converting InputStream into String without using any third party library", 
        "type_": "text", 
        "references": [
          "InputStream", 
          "String"
        ]
      }, 
      {
        "text": "Use StringBuilder for single threaded environment otherwise use StringBuffer", 
        "type_": "text", 
        "references": [
          "StringBuilder", 
          "StringBuffer"
        ]
      }, 
      {
        "text": " ", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "    public static String getString( InputStream is) throws IOException {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        int ch;", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        StringBuilder sb = new StringBuilder();", 
        "type_": "code", 
        "references": [
          "StringBuilder"
        ]
      }, 
      {
        "text": "        while((ch = is.read())!= -1)", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "            sb.append((char)ch);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        return sb.toString();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    }", 
        "type_": "code", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 309448, 
    "lines": [
      {
        "text": "A nice way to do this is using Apache commons IOUtils to copy the InputStream into a StringWriter..", 
        "type_": "text", 
        "references": [
          "IOUtils", 
          "InputStream", 
          "StringWriter"
        ]
      }, 
      {
        "text": "something like", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "StringWriter writer = new StringWriter();", 
        "type_": "code", 
        "references": [
          "StringWriter"
        ]
      }, 
      {
        "text": "IOUtils.copy(inputStream, writer, encoding);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "String theString = writer.toString();", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }, 
      {
        "text": "or even", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "String theString = IOUtils.toString(inputStream, encoding)", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }, 
      {
        "text": "Alternatively, you could use ByteArrayOutputStream if you don't want to mix your Streams and Writers", 
        "type_": "text", 
        "references": [
          "ByteArrayOutputStream"
        ]
      }
    ]
  }, 
  {
    "id_": 25782577, 
    "lines": [
      {
        "text": "The following doesn't address the original question, but rather some of the responses.", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "Several responses suggest loops of the form", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "String line = null;", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }, 
      {
        "text": "while((line = reader.readLine()) != null) {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "  // ...", 
        "type_": "codecommentinline", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "or", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "for(String line = reader.readLine(); line != null; line = reader.readLine()) {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    // ...", 
        "type_": "codecommentinline", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "The first form pollutes the namespace of the enclosing scope by declaring a variable \"read\" in the enclosing scope that will not be used for anything outside the for loop", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "The second form duplicates the readline() call.", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "Here is a much cleaner way of writing this sort of loop in Java", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "It turns out that the first clause in a for-loop doesn't require an actual initializer value", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "This keeps the scope of the variable \"line\" to within the body of the for loop", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "Much more elegant! I haven't seen anybody using this form anywhere (I randomly discovered it one day years ago), but I use it all the time.", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "for (String line; (line = reader.readLine()) != null; ) {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    //...", 
        "type_": "codecommentinline", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 25486003, 
    "lines": [
      {
        "text": "InputStream is = Context.openFileInput(someFileName); // whatever formate you have", 
        "type_": "codecommentinline", 
        "references": [
          "InputStream"
        ]
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "ByteArrayOutputStream bos = new ByteArrayOutputStream();", 
        "type_": "code", 
        "references": [
          "ByteArrayOutputStream"
        ]
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "byte[] b = new byte[1024];", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "while ((int bytesRead = is.read(b)) != -1) {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        bos.write(b, 0, bytesRead);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "byte[] bytes = bos.toByteArray();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "String audioDataString=bytes.toString();", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }
    ]
  }, 
  {
    "id_": 13195413, 
    "lines": [
      {
        "text": "Here's how to do it using just the JDK using byte array buffers", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "This is actually how the commons-io IOUtils.copy() methods all work", 
        "type_": "text", 
        "references": [
          "IOUtils.copy()"
        ]
      }, 
      {
        "text": "You can replace byte[] with char[] if you're copying from a Reader instead of an InputStream.", 
        "type_": "text", 
        "references": [
          "byte[]", 
          "char[]", 
          "Reader", 
          "InputStream"
        ]
      }, 
      {
        "text": "import java.io.ByteArrayOutputStream;", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "import java.io.InputStream;", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "...", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "InputStream is = ....", 
        "type_": "code", 
        "references": [
          "InputStream"
        ]
      }, 
      {
        "text": "ByteArrayOutputStream baos = new ByteArrayOutputStream(8192);", 
        "type_": "code", 
        "references": [
          "ByteArrayOutputStream"
        ]
      }, 
      {
        "text": "byte[] buffer = new byte[8192];", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "int count = 0;", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "try {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "  while ((count = is.read(buffer)) != -1) {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    baos.write(buffer, 0, count);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "  }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "finally {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "  try {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    is.close();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "  }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "  catch (Exception ignore) {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "  }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "String charset = \"UTF-8\";", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }, 
      {
        "text": "String inputStreamAsString = baos.toString(charset);", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }
    ]
  }, 
  {
    "id_": 25103484, 
    "lines": [
      {
        "text": "This is an answer adapted from org.apache.commons.io.IOUtils source code, for those want to have the apache implementation but do not want the whole library.", 
        "type_": "text", 
        "references": [
          "org.apache.commons.io.IOUtils"
        ]
      }, 
      {
        "text": "private static final int BUFFER_SIZE = 4 * 1024;", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "public static String inputStreamToString(InputStream inputStream, String charsetName)", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        throws IOException {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    StringBuilder builder = new StringBuilder();", 
        "type_": "code", 
        "references": [
          "StringBuilder"
        ]
      }, 
      {
        "text": "    InputStreamReader reader = new InputStreamReader(inputStream, charsetName);", 
        "type_": "code", 
        "references": [
          "InputStreamReader"
        ]
      }, 
      {
        "text": "    char[] buffer = new char[BUFFER_SIZE];", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    int length;", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    while ((length = reader.read(buffer)) != -1) {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        builder.append(buffer, 0, length);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    return builder.toString();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 10505933, 
    "lines": [
      {
        "text": "This is my pure Java & Android solution, works well...", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "public String readFully(InputStream inputStream, String encoding)", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        throws IOException {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    return new String(readFully(inputStream), encoding);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "}    ", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "private byte[] readFully(InputStream inputStream)", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        throws IOException {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    ByteArrayOutputStream baos = new ByteArrayOutputStream();", 
        "type_": "code", 
        "references": [
          "ByteArrayOutputStream"
        ]
      }, 
      {
        "text": "    byte[] buffer = new byte[1024];", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    int length = 0;", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    while ((length = inputStream.read(buffer)) != -1) {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        baos.write(buffer, 0, length);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    return baos.toByteArray();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 24104048, 
    "lines": [
      {
        "text": "This one is nice because:", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "What the for?", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "public static String convertStreamToString(InputStream is) { ", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "   StringBuilder sb = new StringBuilder(2048); // Define a size if you have an idea of it.", 
        "type_": "codecommentinline", 
        "references": [
          "StringBuilder"
        ]
      }, 
      {
        "text": "   char[] read = new char[128]; // Your buffer size.", 
        "type_": "codecommentinline", 
        "references": []
      }, 
      {
        "text": "   try (InputStreamReader ir = new InputStreamReader(is, StandardCharsets.UTF_8)) {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "     for (int i; -1 != (i = ir.read(read)); sb.append(read, 0, i));", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "   }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "   return sb.toString();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 23615823, 
    "lines": [
      {
        "text": "I had log4j available, so I was able to use the org.apache.log4j.lf5.util.StreamUtils.getBytes to get the bytes, which I was able to convert into a string using the String ctor", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "String result = new String(StreamUtils.getBytes(inputStream));", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }
    ]
  }, 
  {
    "id_": 21619906, 
    "lines": [
      {
        "text": "Try these 4 statements..", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "As per the point recalled by Fred, it is not recommended to append a String with += operator since every time a new char is appended to the existing String creating a new String object again and assigning its address to st while the old st object becomes garbage.", 
        "type_": "text", 
        "references": [
          "String", 
          "+=", 
          "char", 
          "String", 
          "String", 
          "st", 
          "st"
        ]
      }, 
      {
        "text": "public String convertStreamToString(InputStream is)", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "{", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "int k;", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "     StringBuffer sb=new StringBuffer();", 
        "type_": "code", 
        "references": [
          "StringBuffer"
        ]
      }, 
      {
        "text": "     while((k=fin.read())!=-1)", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "     {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "     sb.append((char)k);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "     }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "return sb.toString();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 21915153, 
    "lines": [
      {
        "text": "I have written a class that does just that, so I figured I'd share it with everyone", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "Sometimes you don't want to add Apache Commons just for one thing, and want something dumber than Scanner that doesn't examine the content.", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "Usage is as follows", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "// Read from InputStream", 
        "type_": "codecommentinline", 
        "references": []
      }, 
      {
        "text": "String data = new ReaderSink(inputStream, Charset.forName(\"UTF-8\")).drain();", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "// Read from File", 
        "type_": "codecommentinline", 
        "references": []
      }, 
      {
        "text": "data = new ReaderSink(file, Charset.forName(\"UTF-8\")).drain();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "// Drain input stream to console", 
        "type_": "codecommentinline", 
        "references": []
      }, 
      {
        "text": "new ReaderSink(inputStream, Charset.forName(\"UTF-8\")).drainTo(System.out);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "Here is the code for ReaderSink:", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "import java.io.*;", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "import java.nio.charset.Charset;", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "/**", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": " * A simple sink class that drains a {@link Reader} to a {@link String} or", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": " * to a {@link Writer}.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": " *", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": " * @author Ben Barkay", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": " * @version 2/20/2014", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": " */", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "public class ReaderSink {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    /**", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * The default buffer size to use if no buffer size was specified.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     */", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "    public static final int DEFAULT_BUFFER_SIZE = 1024;", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    /**", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * The {@link Reader} that will be drained.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     */", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "    private final Reader in;", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    /**", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * Constructs a new {@code ReaderSink} for the specified file and charset.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * @param file      The file to read from.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * @param charset   The charset to use.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * @throws FileNotFoundException    If the file was not found on the filesystem.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     */", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "    public ReaderSink(File file, Charset charset) throws FileNotFoundException {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        this(new FileInputStream(file), charset);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    /**", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * Constructs a new {@code ReaderSink} for the specified {@link InputStream}.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * @param in        The {@link InputStream} to drain.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * @param charset   The charset to use.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     */", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "    public ReaderSink(InputStream in, Charset charset) {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        this(new InputStreamReader(in, charset));", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    /**", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * Constructs a new {@code ReaderSink} for the specified {@link Reader}.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * @param in    The reader to drain.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     */", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "    public ReaderSink(Reader in) {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        this.in = in;", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    /**", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * Drains the data from the underlying {@link Reader}, returning a {@link String} containing", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * all of the read information. This method will use {@link #DEFAULT_BUFFER_SIZE} for", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * its buffer size.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * @return  A {@link String} containing all of the information that was read.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     */", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "    public String drain() throws IOException {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        return drain(DEFAULT_BUFFER_SIZE);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    /**", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * Drains the data from the underlying {@link Reader}, returning a {@link String} containing", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * all of the read information.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * @param bufferSize    The size of the buffer to use when reading.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * @return  A {@link String} containing all of the information that was read.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     */", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "    public String drain(int bufferSize) throws IOException {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        StringWriter stringWriter = new StringWriter();", 
        "type_": "code", 
        "references": [
          "StringWriter"
        ]
      }, 
      {
        "text": "        drainTo(stringWriter, bufferSize);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        return stringWriter.toString();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    /**", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * Drains the data from the underlying {@link Reader}, writing it to the", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * specified {@link Writer}. This method will use {@link #DEFAULT_BUFFER_SIZE} for", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * its buffer size.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * @param out   The {@link Writer} to write to.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     */", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "    public void drainTo(Writer out) throws IOException {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        drainTo(out, DEFAULT_BUFFER_SIZE);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    /**", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * Drains the data from the underlying {@link Reader}, writing it to the", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * specified {@link Writer}.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * @param out           The {@link Writer} to write to.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     * @param bufferSize    The size of the buffer to use when reader.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "     */", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "    public void drainTo(Writer out, int bufferSize) throws IOException {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        char[] buffer = new char[bufferSize];", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        int read;", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        while ((read = in.read(buffer)) > -1) {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "            out.write(buffer, 0, read);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 21912248, 
    "lines": [
      {
        "text": "This snippet was found in \\sdk\\samples\\android-19\\connectivity\\NetworkConnect\\NetworkConnectSample\\src\\main\\java\\com\\example\\android\\networkconnect\\MainActivity.java which is licensed under Apache License, Version 2.0 and written by Google.", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "/** Reads an InputStream and converts it to a String.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": " * @param stream InputStream containing HTML from targeted site.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": " * @param len Length of string that this method returns.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": " * @return String concatenated according to len parameter.", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": " * @throws java.io.IOException", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": " * @throws java.io.UnsupportedEncodingException", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": " */", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "private String readIt(InputStream stream, int len) throws IOException, UnsupportedEncodingException {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    Reader reader = null;", 
        "type_": "code", 
        "references": [
          "Reader"
        ]
      }, 
      {
        "text": "    reader = new InputStreamReader(stream, \"UTF-8\");", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    char[] buffer = new char[len];", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    reader.read(buffer);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    return new String(buffer);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 7743991, 
    "lines": [
      {
        "text": "I ran some timing tests because time matters, always.", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "I attempted to get the response into a String 3 different ways", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "(shown below)\nI left out try/catch blocks for the sake readability.", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "To give context, this is the preceding code for all 3 approaches:", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "   String response;", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }, 
      {
        "text": "   String url = \"www.blah.com/path?key=value\";", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }, 
      {
        "text": "   GetMethod method = new GetMethod(url);", 
        "type_": "code", 
        "references": [
          "GetMethod"
        ]
      }, 
      {
        "text": "   int status = client.executeMethod(method);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "1)", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": " response = method.getResponseBodyAsString();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "2)", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "InputStream resp = method.getResponseBodyAsStream();", 
        "type_": "code", 
        "references": [
          "InputStream"
        ]
      }, 
      {
        "text": "InputStreamReader is=new InputStreamReader(resp);", 
        "type_": "code", 
        "references": [
          "InputStreamReader"
        ]
      }, 
      {
        "text": "BufferedReader br=new BufferedReader(is);", 
        "type_": "code", 
        "references": [
          "BufferedReader"
        ]
      }, 
      {
        "text": "String read = null;", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }, 
      {
        "text": "StringBuffer sb = new StringBuffer(read);", 
        "type_": "code", 
        "references": [
          "StringBuffer"
        ]
      }, 
      {
        "text": "while((read = br.readLine()) != null) {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    sb.append(read);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "response = sb.toString();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "3)", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "InputStream iStream  = method.getResponseBodyAsStream();", 
        "type_": "code", 
        "references": [
          "InputStream"
        ]
      }, 
      {
        "text": "StringWriter writer = new StringWriter();", 
        "type_": "code", 
        "references": [
          "StringWriter"
        ]
      }, 
      {
        "text": "IOUtils.copy(iStream, writer, \"UTF-8\");", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "response = writer.toString();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "So, after running 500 tests on each approach with the same request/response data, here are the numbers", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "Once again, these are my findings and your findings may not be exactly the same, but I wrote this to give some indication to others of the efficiency differences of these approaches.", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "Ranks:\nApproach #1\nApproach #3 - 2.6% slower than #1\nApproach #2 - 4.3% slower than #1", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "Any of these approaches is an appropriate solution for grabbing a response and creating a String from it.", 
        "type_": "text", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 21163930, 
    "lines": [
      {
        "text": "You can use apache commons", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "In the IOUtils you can find the toString metod with 3 helpfull implementations.", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "public static String toString(InputStream input) throws IOException {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        return toString(input, Charset.defaultCharset());", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "public static String toString(InputStream input) throws IOException {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        return toString(input, Charset.defaultCharset());", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "public static String toString(InputStream input, String encoding)", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "            throws IOException {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        return toString(input, Charsets.toCharset(encoding));", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 350723, 
    "lines": [
      {
        "text": "Apache Commons allows: ", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "String myString = IOUtils.toString(myInputStream, \"UTF-8\");", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }, 
      {
        "text": "Of course, you could choose other character encodings besides UTF-8", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "Also see: (Docs)", 
        "type_": "text", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 14107694, 
    "lines": [
      {
        "text": "Here's the most elegant, pure-Java (no library) solution I came up with after some experimentation:", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "public static String fromStream(InputStream in) throws IOException", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "{", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    BufferedReader reader = new BufferedReader(new InputStreamReader(in));", 
        "type_": "code", 
        "references": [
          "BufferedReader"
        ]
      }, 
      {
        "text": "    StringBuilder out = new StringBuilder();", 
        "type_": "code", 
        "references": [
          "StringBuilder"
        ]
      }, 
      {
        "text": "    String newLine = System.getProperty(\"line.separator\");", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }, 
      {
        "text": "    String line;", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }, 
      {
        "text": "    while ((line = reader.readLine()) != null) {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        out.append(line);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        out.append(newLine);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    return out.toString();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 20407168, 
    "lines": [
      {
        "text": "JDK 7/8 answer that closes the stream and still throws an IOException:", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "StringBuilder build = new StringBuilder();", 
        "type_": "code", 
        "references": [
          "StringBuilder"
        ]
      }, 
      {
        "text": "byte[] buf = new byte[1024];", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "int length;", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "try (InputStream is = getInputStream()) {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "  while ((length = is.read(buf)) != -1) {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    build.append(new String(buf, 0, length));", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "  }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 15315403, 
    "lines": [
      {
        "text": "Well you can program it for yourself.", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "it's not complicated..", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "String Inputstream2String (InputStream is) throws IOException ", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        final int PKG_SIZE = 1024;", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        byte[] data = new byte [PKG_SIZE];", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        StringBuilder buffer = new StringBuilder(PKG_SIZE * 10);", 
        "type_": "code", 
        "references": [
          "StringBuilder"
        ]
      }, 
      {
        "text": "        int size;", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        size = is.read(data, 0, data.length);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        while (size > 0)", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "            String str = new String(data, 0, size);", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }, 
      {
        "text": "            buffer.append(str);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "            size = is.read(data, 0, data.length);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        return buffer.toString();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    }", 
        "type_": "code", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 5445161, 
    "lines": [
      {
        "text": "Here's a way using only standard Java library (note that the stream is not closed, YMMV).", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "static String convertStreamToString(java.io.InputStream is) {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    java.util.Scanner s = new java.util.Scanner(is).useDelimiter(\"\\\\A\");", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    return s.hasNext() ? s.next() : \"\";", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "I learned this trick from \"Stupid Scanner tricks\" article", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "The reason it works is because Scanner iterates over tokens in the stream, and in this case we separate tokens using \"beginning of the input boundary\" (\\A) thus giving us only one token for the entire contents of the stream.", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "Note, if you need to be specific about the input stream's encoding, you can provide the second argument to Scanner constructor that indicates what charset to use (e.g", 
        "type_": "text", 
        "references": [
          "Scanner"
        ]
      }, 
      {
        "text": "\"UTF-8\").", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "Hat tip goes also to Jacob, who once pointed me to the said article.", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "EDITED: Thanks to a suggestion from Patrick, made the function more robust when handling an empty input stream", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "One more edit: nixed try/catch, Patrick's way is more laconic.", 
        "type_": "text", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 16839350, 
    "lines": [
      {
        "text": "InputStreamReader i=new InputStreamReader(s);", 
        "type_": "code", 
        "references": [
          "InputStreamReader"
        ]
      }, 
      {
        "text": "BufferedReader str=new BufferedReader(i);", 
        "type_": "code", 
        "references": [
          "BufferedReader"
        ]
      }, 
      {
        "text": "String msg=str.readLine();", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }, 
      {
        "text": "System.out.println(msg);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "here s is your InputStream object which will get convert into String :)", 
        "type_": "text", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 16487716, 
    "lines": [
      {
        "text": "  InputStream IS=new URL(\"http://www.petrol.si/api/gas_prices.json\").openStream();   ", 
        "type_": "codecommentinline", 
        "references": [
          "InputStream"
        ]
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "  ByteArrayOutputStream BAOS=new ByteArrayOutputStream();", 
        "type_": "code", 
        "references": [
          "ByteArrayOutputStream"
        ]
      }, 
      {
        "text": "  IOUtils.copy(IS, BAOS);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "  String d= new String(BAOS.toByteArray(),\"UTF-8\");           ", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "System.out.println(d);", 
        "type_": "code", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 3238954, 
    "lines": [
      {
        "text": "If you are using Google-Collections/Guava you could do the following:", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "InputStream stream = ...", 
        "type_": "code", 
        "references": [
          "InputStream"
        ]
      }, 
      {
        "text": "String content = CharStreams.toString(new InputStreamReader(stream, Charsets.UTF_8));", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }, 
      {
        "text": "Closeables.closeQuietly(stream);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "Note that the second parameter (i.e", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "Charsets.UTF_8) for the InputStreamReader isn't necessary, but it is generally a good idea to specify the encoding if you know it (which you should!)", 
        "type_": "text", 
        "references": [
          "InputStreamReader"
        ]
      }
    ]
  }, 
  {
    "id_": 309718, 
    "lines": [
      {
        "text": "Taking into account file one should first get a java.io.Reader instance", 
        "type_": "text", 
        "references": [
          "java.io.Reader"
        ]
      }, 
      {
        "text": "This can then be read and added to a StringBuilder (we don't need StringBuffer if we are not accessing it in multiple threads, and StringBuilder is faster)", 
        "type_": "text", 
        "references": [
          "StringBuilder", 
          "StringBuffer", 
          "StringBuilder"
        ]
      }, 
      {
        "text": "The trick here is that we work in blocks, and as such don't need other buffering streams", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "The block size is parameterized for run-time performance optimization.", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "public static String slurp(final InputStream is, final int bufferSize)", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "{", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "  final char[] buffer = new char[bufferSize];", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "  final StringBuilder out = new StringBuilder();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "  try {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    final Reader in = new InputStreamReader(is, \"UTF-8\");", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    try {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "      for (;;) {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        int rsz = in.read(buffer, 0, buffer.length);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        if (rsz < 0)", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "          break;", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        out.append(buffer, 0, rsz);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "      }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    finally {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "      in.close();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "  }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "  catch (UnsupportedEncodingException ex) {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    /* ... */", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "  }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "  catch (IOException ex) {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "      /* ... */", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "  }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "  return out.toString();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 13430647, 
    "lines": [
      {
        "text": "make sure to close the streams at end if you use Stream Readers", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "    private String readStream(InputStream iStream) throws IOException {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        //build a Stream Reader, it can read char by char", 
        "type_": "codecommentinline", 
        "references": []
      }, 
      {
        "text": "        InputStreamReader iStreamReader = new InputStreamReader(iStream);", 
        "type_": "code", 
        "references": [
          "InputStreamReader"
        ]
      }, 
      {
        "text": "        //build a buffered Reader, so that i can read whole line at once", 
        "type_": "codecommentinline", 
        "references": []
      }, 
      {
        "text": "        BufferedReader bReader = new BufferedReader(iStreamReader);", 
        "type_": "code", 
        "references": [
          "BufferedReader"
        ]
      }, 
      {
        "text": "        String line = null;", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }, 
      {
        "text": "        StringBuilder builder = new StringBuilder();", 
        "type_": "code", 
        "references": [
          "StringBuilder"
        ]
      }, 
      {
        "text": "        while((line = bReader.readLine()) != null) {  //Read till end", 
        "type_": "codecommentinline", 
        "references": []
      }, 
      {
        "text": "            builder.append(line);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        }", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        bReader.close();         //close all opened stuff", 
        "type_": "codecommentinline", 
        "references": []
      }, 
      {
        "text": "        iStreamReader.close();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        iStream.close();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "        return builder.toString();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    }", 
        "type_": "code", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 9949592, 
    "lines": [
      {
        "text": "Here's more-or-less sampath's answer, cleaned up a bit and represented as a function:", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "String streamToString(InputStream in) throws IOException {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "  StringBuilder out = new StringBuilder();", 
        "type_": "code", 
        "references": [
          "StringBuilder"
        ]
      }, 
      {
        "text": "  BufferedReader br = new BufferedReader(new InputStreamReader(in));", 
        "type_": "code", 
        "references": [
          "BufferedReader"
        ]
      }, 
      {
        "text": "  for(String line = br.readLine(); line != null; line = br.readLine()) ", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    out.append(line);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "  br.close();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "  return out.toString();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 6938341, 
    "lines": [
      {
        "text": "How about this?", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "InputStream in = /* your InputStream */;", 
        "type_": "codecommentlong", 
        "references": []
      }, 
      {
        "text": "InputStreamReader is = new InputStreamReader(in);", 
        "type_": "code", 
        "references": [
          "InputStreamReader"
        ]
      }, 
      {
        "text": "StringBuilder sb=new StringBuilder();", 
        "type_": "code", 
        "references": [
          "StringBuilder"
        ]
      }, 
      {
        "text": "BufferedReader br = new BufferedReader(is);", 
        "type_": "code", 
        "references": [
          "BufferedReader"
        ]
      }, 
      {
        "text": "String read = br.readLine();", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "while(read != null) {", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    //System.out.println(read);", 
        "type_": "codecommentinline", 
        "references": []
      }, 
      {
        "text": "    sb.append(read);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    read =br.readLine();", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "}", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "return sb.toString();", 
        "type_": "code", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 11628754, 
    "lines": [
      {
        "text": "The below code worked for me", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "    URL url = MyClass.class.getResource(\"/\" + configFileName);", 
        "type_": "code", 
        "references": [
          "URL"
        ]
      }, 
      {
        "text": "    BufferedInputStream bi = (BufferedInputStream) url.getContent();", 
        "type_": "code", 
        "references": [
          "BufferedInputStream"
        ]
      }, 
      {
        "text": "    byte[] buffer = new byte[bi.available() ];", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    int bytesRead = bi.read(buffer);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    String out = new String(buffer);", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }, 
      {
        "text": "Please note, according to Java docs, the available() method might not work with InputStream but always works with BufferedInputStream", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "In case you don't want to use available() method we can always use the below code", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "    URL url = MyClass.class.getResource(\"/\" + configFileName);", 
        "type_": "code", 
        "references": [
          "URL"
        ]
      }, 
      {
        "text": "    BufferedInputStream bi = (BufferedInputStream) url.getContent();", 
        "type_": "code", 
        "references": [
          "BufferedInputStream"
        ]
      }, 
      {
        "text": "    File f = new File(url.getPath());", 
        "type_": "code", 
        "references": [
          "File"
        ]
      }, 
      {
        "text": "    byte[] buffer = new byte[ (int) f.length()];", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    int bytesRead = bi.read(buffer);", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "    String out = new String(buffer);", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }, 
      {
        "text": "I am not sure if there will be any encoding issues", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "Please comment, if there will be any issues with the code", 
        "type_": "text", 
        "references": []
      }
    ]
  }, 
  {
    "id_": 11566262, 
    "lines": [
      {
        "text": "Quick and easy:", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "String result = (String)new ObjectInputStream( inputStream ).readObject();", 
        "type_": "code", 
        "references": [
          "String"
        ]
      }
    ]
  }, 
  {
    "id_": 9597413, 
    "lines": [
      {
        "text": "If you were feeling adventurous, you could mix Scala and Java and end up with this:", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "scala.io.Source.fromInputStream(is).mkString(\"\")", 
        "type_": "code", 
        "references": []
      }, 
      {
        "text": "Mixing Java and Scala code and libraries has it's benefits.", 
        "type_": "text", 
        "references": []
      }, 
      {
        "text": "See full description here: Idiomatic way to convert an InputStream to a String in Scala", 
        "type_": "text", 
        "references": []
      }
    ]
  }
]
