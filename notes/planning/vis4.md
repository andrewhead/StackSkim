# Planning 4: Brainstorms for User Interfaces

## Purpose

I hope to have some UIST-ready research project completed for next February.
Here is a list of ideas for what interfaces we can build to help solve some problem

## Rules of the brainstorm

* Incorporate at least one thing that you can see, hear, or feel for each interface

## High-priority projects
* A sampler for building augmented code examples with lists of suggestions
* Interface for slicing and cleaning up production code to make usable online code examples
* Sounds that describe code quality, for number of downloads, number of unit tests, number of collaborators
* An interface that re-crafts explanations based on perceived personality
* Manipulable bits for learning what a snippet does by manipulating it and seeing usage examples update
* A single-button compiler of notebooks into reusable modules
* A rhetorical PEP8 that convinces you to write good code as you save files (via seduction, middle-of-the-path, etc.)
* A sink for debugging messages from embedded hardware
* Visually adaptive debugger view for Eclipse that can snap onto any coding editor
* Haptic feedback when running unit tests and something fails

## Better Tutorons interfaces
* Manipulable bits for learning what a snippet does by manipulating it and seeing usage examples update
* Generating diversity-sensitive explanations with Tutorons
* A plugin for collaborative markup on online tutorials
* A sampler for building augmented code examples with lists of suggestions
* Code snippets that send back usage information to the place it was grabbed from
* Make Tutorons available anywhere (e.g., also within the IDE, and anywhere on the desktop)
* An interface that re-crafts explanations based on perceived personality

## Mega list of interfaces
* Interface for slicing and cleaning up production code to make usable online code examples
* A sloppy command line for sharing insights about equations, formulas, and snippets that appear in research papers
* A better search engine front-end for StackOverflow

### Things to make faster
* Brainstorming about future research projects
* A single-button compiler of notebooks into reusable modules
* Code slicing of existing code into a notebook

### Hear
* Buzzing of memory leaks in C
* Emptiness and code library / Github library reuse
* Sounds that describe code quality, for number of downloads, number of unit tests, number of collaborators
* A rhetorical PEP8 that convinces you to write good code as you save files (via seduction, middle-of-the-path, etc.)
* A mental-model tutor and talker that synthesizes good questions about your code as you walk

### See
* The copy-paste camera.  Take picture of code with your camera and transplant anywhere else.  Helpful for embedded programming.
* Unit tests overlaid on code
* Vision-based Tutorons available anywhere on the desktop
* Affinity/attraction between code examples that will fit well in your code and those that won't
* Annotating computer vision code with images of what each function does as a filter
* Animated translations of parse tree components to usage examples (e.g., SQL 'where' clauses)
* A direct manipulation interface for reusing code.  Making blocks-based out of written code examples.
* A sink for debugging messages from embedded hardware
* An interface for inserting breakpoints for deployed embedded hardware
* Story-tale tutorials readings in story-tale voice, to improve recall of material
* SimCity co-representation of code you build, with visualization of "natural disasters" that appear in the future with unexpected runs
* Data-driven development.  Programming with code and data side-by-side for each method built.
* Visual summaries of pipelines of massive If-This-Then-That workflows
* Visually adaptive debugger view for Eclipse that can snap onto any coding editor
* User interface wear: visual indicators to help users of interface know where to go for frequent commands and menus
* A system that listens to your frequent programming languages and recommends when it appears you used the syntax of the wrong language
* Recommendations for Pythonic language that simplifies your parse tree

### Feel
* A coding keyboard that makes things feel rocky when code has not been tested
* Haptic feedback when running unit tests and something fails
* PEP8 realized via haptic feedback.  You feel the unchecked syntax when you program
* A serious game for code slicing with actual slash gestures
* Parsons problems with physical blocks for learning programming
* Jagged selection bounds in the browser for choosing delimited code samples
* Yank out all print statements with a single visual string when you're done programming

## Major themes
* Ambient media for good coding practice
