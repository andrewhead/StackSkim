# Vision 9: Roadmap and Abstracts for "Synthesizing Explanations" and "Mining Tutorials"

In [Vision 8](vis8), I discuss using the Mellis *n*-gram to define a research direction.
Two *n*-grams that merit more research are "synthesis, explanations" and "data mining, tutorials".
Both of these will yield insights that can improve how useful Tutorons are.

Upcoming project ideas include:
* EasyDemo
* Questions Programmers Ask about Online Code
* Something related to explanation synthesis

Systems that we can build after obtaining this knowledge are:
* A code example search engine
* A browser plugin for testing code (EasyDemo)

## Some More Ideas at the Intersection of Tutorial Mining, Explanations, and Programmer Information Needs

Worthwhile projects may include:
* Identifying programmer information needs within-document (in particular, blog tutorials)
* Mining the usability of tutorials by looking for lacks of explanations (see Petrosyan et al.)
* There are two problems in information seeking: selection and coordination.  What are the coordination barriers in the physical computing lab?

## Roadmap

|Time|Project|
|----|-------|
|Nov-Dec 2015|Understand the workflow of sandboxing and testing code found online|
|Jan-Feb 2015|A tool for packaging online code into a virtual environment or script, perhaps with human interaction|
|Jan-May 2015|Question answering: understanding programmer information needs when they work with example code and programming references|
|Mar 2015|Learning outcomes and mental models from working with example code|
|Mar 2015|Ability to design with components referenced in example code and tutorials|
|May-July 2015|Mapping information needs to automatically generated explanations and interactions|

Implications from this round of research for mixed CS disciplines:
* A taxonomy of problems of programmers working with online help
    * Recommendations for tutorial writers and new authoring tools (CHI)
    * Note: it would be even more useful if we stratified this into groups of programmers with varying levels of expertise
* A tool that supports people in testing out others' example code
    * Quicker, more painless use of code by non-programmers (UIST)
* An understanding of the implications of code reuse on building mental models and writing new code
    * Guidelines for CS educators (CSE, ICER, TOCE, VL/HCC)
    * Recommendation of attention techniques for software engineering (TOSEM, etc.)

### Relation to larger goals (synthesizing help and mining tutorials)

Something here.

## Additional Musings

* We could integrate into more than one online textbook.  This could be a textbook unrelated to introductory programming.
* If programmers were asked to author all code as a Markdown-code hybrid (notebook-style), how much better would they learn the concepts?
* What if I interviewed professors about their expectations about what the role of the code example is and the third-party library is?

## Notes from Literature Review

* One advantage of natural language explanations of code is that it is readable.  Source code is not readable if you don't know the language.  Diagrams are not readable if you don't know the abstraction.
* Core values of CS education research include
    * motivating students
    * providing educational resources for all interested students
    * reducing misconceptions
    * enabling technological literacy
