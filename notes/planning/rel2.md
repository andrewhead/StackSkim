# Related Work 2: Programmers Sharing Information

## Technique

Look through the following publications: ICSE, Empirical Software Engineering, TOSEM, TSE, OOPSLA.
For each one, take a chronological look at the titles.
Extract the titles that appear to be relevant to the following questions:
1. Historically, how have programmers shared information?
2. What are known impediments to programmers sharing information?
3. What are the most difficult forms of information to produce?
4. What do we know about the challenges to developing software with hugely distributed, non-social software development
5. What are the requirements to making terrific programming information?
The information I'm interested in is "How-To" information.

I search DBLP, sorting by decreasing recency.
I filter by venue (e.g., include "venue:ICSE:" in the query for ICSE papers)
I manually inspect each title, and copy it here if it appears relevant.

Additional publications that may be related include:
* Social Software Engineering (SSE)
* User Interface Software &amp; Technology (UIST)
* Human Factors in Computing Systems (CHI)
* Visual Languages and Human-Centered Computing (VL/HCC)
* International Conference on Program Comprehensions (ICPC)
* CrowdSourcing in Software Engineering (CSD)
* Context-Oriented Programming (COP)
* Cooperative and Human Aspects on Software Engineering (CHASE)
* Big Data Software Engineering (BIGDSE)
* Automated Software Engineering (ASE)

## Related Works

*Stopped on p. 1124-5 of ICSE 2011*

Some notes about trends:
* Reasons for difficulty working with information include: the information doesn't exist, it's in an unfamiliar representation, or there's too much to feasibly sift through in a short time
* Information may be shared in real time (sketches), or asynchronously (e-mail, bug reports)

### How Have Programmers Shared Information?
The hidden experts in software-engineering communication
On how often code is cloned across repositories
Informing development decisions: from data to information
Content classification of development emails
Specification patterns from research to industry: A case study in service-based applications
Documenting and sharing knowledge about code
Understanding broadcast based peer review on open source software projects.
Using knowledge elicitation to improve Web effort estimation: Lessons from six industrial case studies.
Build It Yourself! Homegrown Tools in a Large Software Company
Uncertainty, risk, and information value in software requirements and architecture.
Efficient reuse of domain-specific test knowledge: An industrial case in the smart card domain.
How do programmers ask and answer questions on the web?
"Should We Move to Stack Overflow?" Measuring the Utility of Social Media for Developer Support.
Borrowing from the Crowd: A Study of Recombination in Software Design Competitions
Qualitative Analysis of Knowledge Transfer in Pair Programming
Discovering Information Explaining API Types Using Text Classification
Software engineering at the speed of light: how developers stay current using twitter
Asking and answering questions about unfamiliar APIs: An exploratory study
### Problems or Challenges with Existing Information Systems
How do professional developers comprehend software?
Pathways to technology transfer and adoption: achievements and challenges (mini-tutorial)
Departures from optimality: understanding human analyst's information foraging in assisted requirements tracing.
Expectations, outcomes, and challenges of modern code review
Code Reviews Do Not Find Bugs. How the Current Code Review Best Practice Slows Us Down
Reducing human effort and improving quality in peer code reviews using automatic static analysis and reviewer recommendation.
Disengagement in pair programming: Does it matter?
Software process improvement through the identification and removal of project-level knowledge flow obstacles
Information foraging as a foundation for code navigation
Learning to adapt requirements specifications of evolving systems
Understanding understanding source code with functional magnetic resonance imaging
### Information that Isn't Produced Well Enough
Information needs for software development analytics
Learning to Log: Helping Developers Make Informed Logging Decisions
Automatic Documentation Generation via Source Code Summarization.
AR-miner: mining informative reviews for developers from mobile app marketplace.
An ontology toolkit for problem domain concept location in program comprehension
Characterizing logging practices in open-source software
### Information Sharing for Distributed Teams
Creating a shared understanding of testing culture on a social coding site
Categorizing bugs with social networks: a case study on four open source software communities.
The co-evolution of socio-technical structures in sustainable software development: Lessons from the open source software communities
Does latitude hurt while longitude kills? geographical and temporal separation in a large scale software development project.
How to make best use of cross-company data in software effort estimation?
Distributed development considered harmful?
Collaboration patterns in distributed software development projects
Architectural task allocation in distributed environment: A traceability perspective
Configuring global software teams: a multi-company analysis of project productivity, quality, and profits
The role of domain knowledge and cross-functional communication in socio-technical coordination
Is time-zone proximity an advantage for software development? the case of the brazilian IT industry
What make long term contributors: Willingness and opportunity in OSS community
### Guidelines for Successful Information Sharing
What good are strong specifications?
How do API documentation and static typing affect API usability?
Systematically selecting a software module during opportunistic reuse
From Developer Networks to Verified Communities: A Fine-Grained Approach
What Makes a Great Software Engineer?
Effects of using examples on structural model comprehension: a controlled experiment.
Enabling the Definition and Enforcement of Governance Rules in Open Source Systems
### Augmenting Information Systems
Ambient awareness of build status in collocated software teams.
Normalizing source code vocabulary to support program comprehension and software quality
Spotting working code examples.
Helping Developers Help Themselves: Automatic Decomposition of Code Review Changesets
Interactive Code Review for Systematic Changes
Improving Student Group Work with Collaboration Patterns: A Case Study
Changeset based developer communication to detect software failures
Where should the bugs be fixed? More accurate information retrieval-based bug localization based on bug reports.
Sketching tools for ideation
Blending freeform and managed information in tables
Pragmatic reuse in web application development
Source Code Curation on StackOverflow: The Vesperin System
ChangeScribe: A Tool for Automatically Generating Commit Messages
Poster: Interactive and Collaborative Source Code Annotation
How Can I Use This Method?
Situational awareness: personalizing issue tracking systems
On extracting unit tests from interactive live programming sessions
Seahawk: stack overflow in the IDE
MCT: a tool for commenting programs by multimedia comments
An approach to documenting and evolving architectural design decisions
Where does this code come from and where does it go? - Integrated code history tracker for open source systems
Inferring class level specifications for distributed systems
Augmented intelligence - The new AI - Unleashing human capabilities in knowledge work
Continuous social screencasting to facilitate software tool discovery
UDesignIt: Towards social media for community-driven design.
Exploring techniques for rationale extraction from existing documents
Influencing the adoption of software engineering methods using social software
Facilitating communication between engineers with CARES
Bridging the divide between software developers and operators using logs
Online sharing and integration of results from mining software repositories
aComment: mining annotations from comments and code to detect interrupt related concurrency bugs
On-demand feature recommendations derived from mining public product descriptions
Capturing tacit architectural knowledge using the repertory grid technique
Towards architectural information in implementation
BQL: capturing and reusing debugging knowledge
StakeSource2.0: using social networks of stakeholders to identify and prioritise requirements
Miler: a toolset for exploring email data
Exploring, exposing, and exploiting emails to include human factors in software engineering
### Relevant to other projects
Leveraging Informal Documentation to Summarize Classes and Methods in Context
Analyze this! 145 questions for data scientists in software engineering.
Inferring likely mappings between APIs.
LASE: locating and applying systematic edits by learning from examples.
Recovering traceability links between an API and its learning resources
Synthesizing API usage examples.
Semi-automatically extracting FAQs to improve accessibility of software development knowledge
Inferring method specifications from natural language API descriptions
Automatic parameter recommendation for practical API usage
Recommending source code for use in rapid software prototypes
Experiences with text mining large collections of unstructured systems development artifacts at jpl
Searching, selecting, and synthesizing source code
## Selected Works

### Creating and Evolving Developer Documentation: Understanding Decisions of Open Source Contributors

### A Survey of the Use of Crowdsourcing in Software Engineering

### Knowledge Management in Distributed Agile Software Development

### Agile Documentation, Anyone?

## Ideas

* A system that shows a link between changes to code and the relevant parts of documentation.
    * It filling out what has changed recently in your experiment design.
    * How do we make it easier for people to keep good, comprehensive notes?
    * Remind them what they have to write about, and write most of it for them!
    * Consider the domain of experiment and algorithm design, where precision in description is key
* One cool thing about API reference docs is that you always have a checklist of what has been explained and what hasn't.  However, GSGs take and HowTos take design, in need-finding, understanding user prior knowledge (skills and mental models), and refinement based on user outcomes.  This might necessitate a toolkit or certain way of sharing information to ease how GSGs and HowTos are written.
* Some reasons why people don't share their work (document templates, code, videos of the work) is because it could be embarrassing.  It may be embarrassing because it's unfinished/untrue, because it's linked to their identity, or it's sloppy.  Crowds or text analysis might be put to work to anonymize, clean, and complete uncompleted work.
